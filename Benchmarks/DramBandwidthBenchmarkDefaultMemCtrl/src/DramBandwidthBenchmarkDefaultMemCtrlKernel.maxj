/***
    Here we benchmark how DRAM bandwidth (simple reads from DRAM
    using default memory controller and linear access pattern)
    scales with the number of single precision vector entries
    read from an input stream.
*/
import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;


class DramBandwidthBenchmarkDefaultMemCtrlKernel extends Kernel {

    private static final DFEType dataType   = dfeFloat(8, 24); // C float

    private static final int     numElements = 48*2;
    private static final DFEVectorType dataVectorType =
                                         new DFEVectorType<DFEVar> (dataType, numElements);

    protected DramBandwidthBenchmarkDefaultMemCtrlKernel(KernelParameters parameters)
    {
        super(parameters);

        DFEVar totalVectorEntries   = io.scalarInput("vectorSize", dfeUInt(32));
        DFEVar kernelTicks          = control.count.simpleCounter(32);
        DFEVector<DFEVar> input     = io.input("vector", dataVectorType,
                                                kernelTicks < totalVectorEntries/numElements);

        // we need to do some work to avoid optimising this kernel out completely.
        DFEVar sum = summationTree(input, 0, numElements-1);

        // we need to output something to avoid optimising it out, but we also want not
        // to spoil perf. figures for memory reads => writing one PCIe burst (16 bytes).
        io.output("sum", sum, dataType, control.count.pulse(4) );
    }

    // Recursively produce binary tree of additions. Leaf nodes are
    // offsets to source stream.
    private DFEVar summationTree(DFEVector<DFEVar> src, int left, int right)
    {
        if (left == right)
        {
            return src[left];
        }
        int middle = left + (right - left)/2;
        return summationTree(src, left, middle) + summationTree(src, middle + 1, right);
    }
}
