/***
    Here we provide an example use case of irregular fetch buffer.

    Normally, each cycle we push tupleSize values to the buffer and fetch
    only the number of entries specified by control stream 'sizes'.

    The buffer occasionally issues stall signal (nextPushEnable() == 0)
    to avoid overflow of internal FIFOs. To complicate the example further,
    we occasionally disable data pushes and pops.

    Caveat: using 64-bit floating point (double) stream is _impossible_
    with state machines. State machine must declare its internal type
    as dfeUInt(64), but casting 64-bit float to integer results in compile
    error:

     ERROR:   Cannot cast {HWFloat:11, 53} to {HWOffsetFix:64, 0, UNSIGNED}: Maximum allowed 
     ERROR:   destination bit width for SignMode UNSIGNED is 63 (bit width of destination 
     ERROR:   type: 64)

    Here we workaround it by casting 64-bit floats to 63-bit floats and back.
*/

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;

class FetchSubTupleKernel extends Kernel
{
    private static final DFEType floatType        = dfeFloat(11,53);
    // 
    private static final DFEType reducedFloatType = dfeFloat(11,52);

    private static final DFEType scalarType = dfeUInt(32);

    protected FetchSubTupleKernel(KernelParameters parameters, int tupleSize)
    {
        super(parameters);

        DFEVectorType<DFEVar> tupleType =
                new DFEVectorType<DFEVar> (floatType, tupleSize);

        DFEVectorType<DFEVar> reducedTupleType =
                new DFEVectorType<DFEVar> (reducedFloatType, tupleSize);


        DFEVar cycleCounter = control.count.simpleCounter(32);
        DFEVar prefetchEnable = cycleCounter < 1;
        DFEVar pushEnable = ~prefetchEnable & ( (cycleCounter < 27) | (cycleCounter > 30) );
        DFEVar popEnable  = ~prefetchEnable & ( (cycleCounter < 10) | (cycleCounter > 11) );

        debug.simPrintf("\ncycle=%d ", cycleCounter);



        DFEVar dataRequestEnableLoop = dfeBool().newInstance(this);
        DFEVar dataRequestEnable = control.count.pulse(1)? 0 : stream.offset(dataRequestEnableLoop,-1);

        DFEVector<DFEVar> input = io.input("input", tupleType, dataRequestEnable);
        DFEVar size             = io.input("sizes", scalarType, popEnable);

        boolean alignOutput = true;
        FetchSubTuple buffer = new FetchSubTuple(this, tupleSize, 63, reducedFloatType, alignOutput);
        DFEVar success = buffer.push(pushEnable, input.cast(reducedTupleType));
        DFEVar subTupleSize = (popEnable)? size: 0;
        DFEVector<DFEVar> outTuple = buffer.pop(subTupleSize).cast(tupleType);

        dataRequestEnableLoop <== buffer.nextPushEnable() & stream.offset(pushEnable,1);


        debug.simPrintf("|prefetchEnable=%d, pushEnable=%d, popEnable=%d, size=%d, subTupleSize=%d, dataRequestEnable=%d, nextPushEnable=%d, pushSuccessful=%d, ",
                          prefetchEnable, pushEnable, popEnable, size, subTupleSize, dataRequestEnable, dataRequestEnableLoop, success);
        debug.simPrintf("outTuple: ");
        for (int i = 0; i < tupleSize; i++)
        {
            debug.simPrintf("%f ", outTuple[i]);
        }

        io.output("output", outTuple, tupleType);
    }
}
