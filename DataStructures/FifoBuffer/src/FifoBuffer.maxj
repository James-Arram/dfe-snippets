/***
    This implements a FIFO buffer of fixed length as shift register.
    Push and Pop operations are performed same time. Data movements
    are done with 1 cycle latency.

    Input value is put to the end of a buffer and will come out
    (return value) only after bufferCapacity enabled cycles.
    The output at first bufferCapacity cycles is undefined.

    NB: this design can be a bottleneck to increasing kernel frequency
    due to no pipelining.
*/

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;

class FifoBuffer extends KernelLib
{
    private DFEVector<DFEVar> m_buffer;
    private int m_capacity;
    private DFEType m_contentType;

    public FifoBuffer(KernelLib owner, int bufferCapacity, DFEType dataType)
    {
        super(owner);

        m_capacity = bufferCapacity;
        m_contentType = dataType;
        m_buffer =
               new DFEVectorType<DFEVar> (m_contentType, m_capacity).newInstance(this);
    }

    public DFEVar pushPop(DFEVar enable, DFEVar input)
    {
        DFEVar stored = m_contentType.newInstance(this);

        optimization.pushPipeliningFactor(0.0);
        {
            // pop last entry
            stored <== enable? stream.offset(m_buffer[m_capacity-1],-1)
                             : stream.offset(stored,-1);

            // shift data, overwriting (m_capacity-1)-th item
            for (int i = 1; i < m_capacity; i++)
            {
                m_buffer[i] <== enable? stream.offset(m_buffer[i-1],-1)
                                      : stream.offset(m_buffer[i],  -1);
            }
            // push new entry
            m_buffer[0] <== enable? input : stream.offset(m_buffer[0],-1);
        }
        optimization.popPipeliningFactor();

        return stored;
    }

}
